using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Anatawa12.AvatarOptimizer.PatchApplier
{
    /// <summary>
    /// Represents information about an applied patch
    /// </summary>
    internal class PatchInfo
    {
        public string CommitHash { get; set; }
        public string BaseVersion { get; set; }
        public string BaseCommit { get; set; }
        public string? BasePatch { get; set; }
        public string? PullRequest { get; set; }
        public DateTime AppliedAt { get; set; }

        public PatchInfo(string commitHash, string baseVersion, string baseCommit)
        {
            CommitHash = commitHash ?? throw new ArgumentNullException(nameof(commitHash));
            BaseVersion = baseVersion ?? throw new ArgumentNullException(nameof(baseVersion));
            BaseCommit = baseCommit ?? throw new ArgumentNullException(nameof(baseCommit));
            AppliedAt = DateTime.UtcNow;
        }
    }

    /// <summary>
    /// Manages the list of applied patches stored in .patches.txt
    /// </summary>
    internal class PatchRegistry
    {
        private const string PatchesFileName = ".patches.txt";
        private readonly List<PatchInfo> _patches = new List<PatchInfo>();

        public IReadOnlyList<PatchInfo> Patches => _patches;

        public static string GetPatchesFilePath()
        {
            return Path.Combine("Packages", "com.anatawa12.avatar-optimizer", PatchesFileName);
        }

        /// <summary>
        /// Loads patch information from .patches.txt
        /// </summary>
        public static PatchRegistry Load()
        {
            var registry = new PatchRegistry();
            var patchesPath = GetPatchesFilePath();

            if (!File.Exists(patchesPath))
                return registry;

            try
            {
                var lines = File.ReadAllLines(patchesPath, Encoding.UTF8);
                PatchInfo? currentPatch = null;

                foreach (var line in lines)
                {
                    if (string.IsNullOrWhiteSpace(line) || line.TrimStart().StartsWith("#"))
                        continue;

                    // Parse YAML-like format
                    if (line.StartsWith("- patch:"))
                    {
                        if (currentPatch != null)
                            registry._patches.Add(currentPatch);
                        currentPatch = null;
                    }
                    else if (line.StartsWith("  commit: "))
                    {
                        var commitHash = line.Substring("  commit: ".Length).Trim();
                        if (currentPatch == null && !string.IsNullOrEmpty(commitHash))
                        {
                            currentPatch = new PatchInfo(commitHash, "", "");
                        }
                    }
                    else if (currentPatch != null)
                    {
                        if (line.StartsWith("  base-version: "))
                            currentPatch.BaseVersion = line.Substring("  base-version: ".Length).Trim();
                        else if (line.StartsWith("  base-commit: "))
                            currentPatch.BaseCommit = line.Substring("  base-commit: ".Length).Trim();
                        else if (line.StartsWith("  base-patch: "))
                            currentPatch.BasePatch = line.Substring("  base-patch: ".Length).Trim();
                        else if (line.StartsWith("  pull-request: "))
                            currentPatch.PullRequest = line.Substring("  pull-request: ".Length).Trim();
                        else if (line.StartsWith("  applied-at: "))
                        {
                            if (DateTime.TryParse(line.Substring("  applied-at: ".Length).Trim(), out var appliedAt))
                                currentPatch.AppliedAt = appliedAt;
                        }
                    }
                }

                if (currentPatch != null)
                    registry._patches.Add(currentPatch);
            }
            catch (Exception)
            {
                // If parsing fails, return empty registry
                registry._patches.Clear();
            }

            return registry;
        }

        /// <summary>
        /// Saves patch information to .patches.txt
        /// </summary>
        public void Save()
        {
            var patchesPath = GetPatchesFilePath();
            var sb = new StringBuilder();

            sb.AppendLine("# Avatar Optimizer Applied Patches");
            sb.AppendLine("# This file is automatically generated and should not be edited manually");
            sb.AppendLine();

            foreach (var patch in _patches)
            {
                sb.AppendLine("- patch:");
                sb.AppendLine($"  commit: {patch.CommitHash}");
                sb.AppendLine($"  base-version: {patch.BaseVersion}");
                sb.AppendLine($"  base-commit: {patch.BaseCommit}");
                if (!string.IsNullOrEmpty(patch.BasePatch))
                    sb.AppendLine($"  base-patch: {patch.BasePatch}");
                if (!string.IsNullOrEmpty(patch.PullRequest))
                    sb.AppendLine($"  pull-request: {patch.PullRequest}");
                sb.AppendLine($"  applied-at: {patch.AppliedAt:O}");
            }

            File.WriteAllText(patchesPath, sb.ToString(), Encoding.UTF8);
        }

        /// <summary>
        /// Adds a new patch to the registry
        /// </summary>
        public void AddPatch(PatchInfo patch)
        {
            _patches.Add(patch);
        }

        /// <summary>
        /// Checks if we can apply a new patch (validates continuity)
        /// </summary>
        public bool CanApplyPatch(PatchInfo newPatch)
        {
            // If no patches are applied, we can apply if it's based on current version
            if (_patches.Count == 0)
                return true;

            // If patches are applied, new patch must be based on the last applied patch
            var lastPatch = _patches[_patches.Count - 1];
            
            // New patch must be based on the last patch's commit
            return newPatch.BasePatch == lastPatch.CommitHash;
        }

        /// <summary>
        /// Gets a version string that includes patch information
        /// </summary>
        public string GetVersionString(string baseVersion)
        {
            if (_patches.Count == 0)
                return baseVersion;

            var lastPatch = _patches[_patches.Count - 1];
            var shortHash = lastPatch.CommitHash.Length >= 9 
                ? lastPatch.CommitHash.Substring(0, 9) 
                : lastPatch.CommitHash;
            
            return $"{baseVersion}+patch.{shortHash}";
        }

        /// <summary>
        /// Gets full commit hash for header field
        /// </summary>
        public string? GetFullCommitHash()
        {
            return _patches.Count > 0 ? _patches[_patches.Count - 1].CommitHash : null;
        }
    }
}
